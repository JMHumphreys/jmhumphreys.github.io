{
  "hash": "6d7570eaed71ff7ef45f0726a0baa40d",
  "result": {
    "markdown": "---\ntitle: \"CovidCAR Package Overview\"\ndate: \"2023-05-18\"\ncategories: [R, statistical inference]\ndescription: \"CovidCAR is intended to facilitate Covid19 model building, ensembling, and evalutaion\"\nformat:\n  html:\n    df-print: kable\n    code-fold: show\n    code-summary: \"Hide code\"\n    code-overflow: wrap\n    toc-title: Page Contents\n    toc: true\n    toc-depth: 2\n    number-sections: false\n    html-math-method: katex\n    css: styles.css\n    theme: flatly\n    toc-location: left\n    smooth-scroll: true\neditor_options: \n  chunk_output_type: console\n---\n\n<style type=\"text/css\">\n\nbody, td {\n   font-size: 13pt;\n}\ncode.r{\n  font-size: 11pt;\n}\npre {\n  font-size: 11pt\n}\n</style>\n\n\n    \n# Overview\nThis introduction briefly outlines core functions used to preprocess observation data, build spatial-temporal models, and post-process model outputs.  Its purpose is to demonstrate a standard workflow not to provide an in depth examination of functions or model building techniques.  \n\n## Resources  \n+ [The CovidCAR GitHub page](https://github.com/JMHumphreys/CovidCAR)    \n+ [CovidCAR Functions Reference site](https://jmhumphreys.github.io/CovidCAR/reference/index.html)  \n  \n  \n# Preliminaries   \n**Load needed packages**  \nA few of these packages are not available on CRAN and will need to be installed from other locations.  \n\n::: {.cell}\n\n```{.r .cell-code}\n#comments and prompts\noptions(dplyr.summarise.inform = FALSE)\nlibrary(cli)\n\n\n#wrangling\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(arrow)\nlibrary(Hmisc)\nlibrary(yaml)\n\n#spatial manipulation\nlibrary(sp)\nlibrary(sf)\nlibrary(spdep)\nlibrary(rgeos)\nlibrary(igraph)\nlibrary(maptools)\nlibrary(mapproj)\n\n#census data\nlibrary(censusapi)\n\n#forecast data\nlibrary(zoltr) #Not available on CRAN\n#remotes::install_github(\"reichlab/zoltr\")\nlibrary(covidHubUtils) #Not available on CRAN\n#remotes::install_github(\"reichlab/covidHubUtils\")\n\n#inference\nlibrary(INLA) #Not available on CRAN\n#install.packages(\"INLA\",repos=c(getOption(\"repos\"),\n#INLA=\"https://inla.r-inla-download.org/R/stable\"), dep=TRUE)\n\nlibrary(EpiEstim)\nlibrary(forecast)\n```\n:::\n\n\n[**CovidCAR**](https://github.com/JMHumphreys/CovidCAR) currently on GitHub  \n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(CovidCAR)\n#devtools::install_github(\"JMHumphreys/CovidCAR\")\n```\n:::\n\n\n# Setup Analysis \n\n## Specifiy Dates and Directories \nThe *setup_analysis()* function defines key date thresholds for model training and forecast horizon periods and should always be run before using any other functions in the **CovidCAR** package.  The dates are written to a yaml file for use by other functions.  \n  \nThe function also allows for recording directory paths to (optionally) write outputs outside of the working directory or to pull previously cached observation data (cache as created with **Covid19Forecast**.v1).  \n\n::: {.cell}\n\n```{.r .cell-code}\nmy_ouputs <- \"C:/Users/unp7/Desktop/Misc/CovidCAR_test\"\nmy_local <- \"C:/Users/unp7/Desktop/GitHub/covid19Forecasts/local/cache\"\n\nsetup_analysis(report_date = \"2021-08-23\", #report date, first forecast day\n               training_period = 2*28, #days\n               forecast_horizon = 28, #days\n               output_dir = my_ouputs, #write outputs here\n               local_cache_dir = my_local #cache\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Your local cache will be available to get_covid19_obs()\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Analysis outputs will be written to C:/Users/unp7/Desktop/Misc/CovidCAR_test/2021-08-23-CovidCAR-run2023-05-23\n```\n:::\n:::\n\n\n## Define Spatial Domain\nThe *download_boundaries()* function pulls US State and territorial boundaries (ESRI shapefiles) from sources in the public domain.  Some basic projection is performed, the shapefile is converted to a SpatialPolygonsDataFrame, and data attributes for a location identifier ('Region') and name ('State') are appended to the object.  \n  \nNOTE: The function includes an option to download county boundaries (unit=\"county\") but there are some timeout issues that need to be resolved due to large file size.     \n\n::: {.cell}\n\n```{.r .cell-code}\nStates <- download_boundaries(unit = \"state\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Downloading polygon files...\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `us-state-boundaries' from data source \n  `C:\\Users\\unp7\\Desktop\\Misc\\CovidCAR_test\\2021-08-23-CovidCAR-run2023-05-23\\polygons' \n  using driver `ESRI Shapefile'\nSimple feature collection with 56 features and 20 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -179.2311 ymin: -14.60181 xmax: 179.8597 ymax: 71.44069\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nclass(States)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SpatialPolygonsDataFrame\"\nattr(,\"package\")\n[1] \"sp\"\n```\n:::\n\n```{.r .cell-code}\nhead(States@data[,c(\"Region\", \"State\")]) #appended attributes  \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| Region|State          |\n|------:|:--------------|\n|      1|Virgin Islands |\n|      2|Wisconsin      |\n|      3|Vermont        |\n|      4|New Jersey     |\n|      5|Colorado       |\n|      6|South Carolina |\n\n</div>\n:::\n:::\n\n\n## Adjacency Graph\nThe *get_neighbors()* function is used to identify polygons (States and Territories in this example) that are located next to each other.  Neighbor information is recorded in a matrix (dimensions: location*location) that is included with the CAR model.  Estimates for any one location are then 'conditional' on the estimates for surrounding locations.   \n   \nNOTE: Polygons representing locations such as Hawaii and Guam are isolated from other locations (termed 'islands') and can be problematic.  One option in this situation is to force connections between locations; the function's 'connect' option will force connections between islands and other locations based on proximity.   \n   \n**Example: Islands with \"no links\"** \n\n::: {.cell}\n\n```{.r .cell-code}\nnb_islands = get_neighbors(States, connect=FALSE)\nsummary(nb_islands) #note that \"7 regions with no links\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 56 \nNumber of nonzero links: 224 \nPercentage nonzero weights: 7.142857 \nAverage number of links: 4 \n7 regions with no links:\n1 24 32 33 38 42 54\nLink number distribution:\n\n 0  1  2  3  4  5  6  7  8 \n 7  1  4  9  9 10 12  2  2 \n1 least connected region:\n13 with 1 link\n2 most connected regions:\n49 56 with 8 links\n```\n:::\n:::\n\n  \n**Example: All locations linked**   \n\n::: {.cell}\n\n```{.r .cell-code}\nnb_coerced = get_neighbors(States, connect=TRUE)\nsummary(nb_coerced)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 56 \nNumber of nonzero links: 242 \nPercentage nonzero weights: 7.716837 \nAverage number of links: 4.321429 \nLink number distribution:\n\n 1  2  3  4  5  6  7  8 \n 5  3 10 12 10 11  3  2 \n5 least connected regions:\n1 13 38 42 54 with 1 link\n2 most connected regions:\n49 56 with 8 links\n```\n:::\n:::\n\n\n**View mapped adjacency**  \nThe *plot_neighbors()* function overlays adjacency connections on mapped location boundaries.    \n\n::: {.cell}\n\n```{.r .cell-code}\nplot_neighbors(States, nb_islands)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRegions defined for each Polygons\n```\n:::\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot_neighbors(States, nb_coerced)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRegions defined for each Polygons\n```\n:::\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-7-2.png){width=672}\n:::\n:::\n\n\n**Convert to INLA Graph**\nThe *nb2INLA()* and *inla.read.graph()* functions are provided by the **INLA** package.  \n\n::: {.cell}\n\n```{.r .cell-code}\nnb2INLA(\"J\", nb_coerced)\nJ = inla.read.graph(\"J\")\n```\n:::\n\n\n# Retrieve Observation Data\nThe *get_covid19_obs()* function downloads hospital incidence data for a specified data range.  \n  \n#### The *source* options for data to be retrieved:\n+ The **covidcast** package  \n+ From a local *cache* as created by the **covid19Forecasts** package (i.e., refactored pipeline pkg)  \n+ From *test* data available from the package itself (sample from summer 2021)     \n\n::: {.cell}\n\n```{.r .cell-code}\nMinDate = min(su_yaml$full_time_span)\nMaxDate = max(su_yaml$full_time_span)\n\ntestData = get_covid19_obs(source = \"covidcast\", \n                           start_date = MinDate, end_date = MaxDate, \n                           write_copy = TRUE)\n#testData = get_covid19_obs(source = \"cache\", start_date = MinDate, end_date = MaxDate)\n#testData = get_covid19_obs(source = \"test\", start_date = MinDate, end_date = MaxDate)\n\ndim(testData)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4534    5\n```\n:::\n\n```{.r .cell-code}\nhead(testData)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|date       | value|signal |location |location_name |\n|:----------|-----:|:------|:--------|:-------------|\n|2021-06-28 |     2|hosp   |02       |Alaska        |\n|2021-06-28 |    29|hosp   |01       |Alabama       |\n|2021-06-28 |    55|hosp   |05       |Arkansas      |\n|2021-06-28 |    75|hosp   |04       |Arizona       |\n|2021-06-28 |   201|hosp   |06       |California    |\n|2021-06-28 |    60|hosp   |08       |Colorado      |\n\n</div>\n:::\n:::\n\n\n**Add Spatial Index**  \nThe *append_region_index()* function matches location names in the observation data to the *Region* index in the polygon boundaries object, which also corresponds with the adjaceny matrix.  The Region index is added as a column to the observations as is a new **trn_tst** column that is coded with either a **trn** or **tst** nominal indicator to distinguish time periods used for model training (observed) and testing (not observed).       \n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data = append_region_index(train_data = testData, polys = States)\nwhich(is.na(train_data$Region))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n:::\n\n\n\n# Forecast Template\nThe *create_forecast_template()* function ensures that each location-time combination in the analysis is represented in the data ingested by the model.  In the case of model runs using only historic observations, this function basically returns the original input but with some column names adjusted.  This because the full date range was already represented.  However, in the case of future dates where observations are not yet available, this function will add a row for each day through the forecast horizon coding the observed incidence *value* as NA as a placeholder.    \n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data = create_forecast_template(train_data)\n```\n:::\n\n\n# Additional Covariates   \nDemo models in this example are fairly simple but in many cases users will want to add additional predictors, signals, or covariates (independent variables).  This section of the script demonstrates how to (1) pull and add demographic variables from the American Community Survey (ACS) and how to (2) add Rt estimates generated from the **EpiEstim** package.    \n   \n## Demographic Data\nThe *getPovertyPop()* function provides a wrapper function for the [**getCensus** package](https://centeronbudget.github.io/getcensus/) for loading American Community Survey (ACS) data from the U.S. Census Bureau.  In this example, an API key ('secret_api') is used to pull the percent of each state's total population in poverty (SAEPOVRTALL_PT) and the number of individuals over the age of 55yrs (given in the *vars_pop* option).\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nPovPop_data = getPovertyPop(key = get_api(\"censusapi\"), #function reads 'secrets.yaml' for specified name\n                            vars_pov = c(\"SAEPOVRTALL_PT\"), \n                            vars_pop = c('AGEGROUP','POP'), \n                            filt_age = c(12,18))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data = left_join(train_data, PovPop_data, by = \"location\")\n```\n:::\n\n\n## Rt Estimation\nThe *Rt_projection()* function combines the *estimate_R()* function from the [**EpiEstim** package](https://github.com/mrc-ide/EpiEstim) with simple timeseries models to forecast Rt estimated over the model training period across the forecast horizon (28 days in the future).  Both the 'raw' Rt estimate ('Rt_raw') for the observation period only and the forecast values ('Rt') are added to the dataframe.   \n  \n#### Forecast models include:\n+ simple ARIMA model using the **forecast** package (method=\"arima\")    \n+ an order-2 random walk with noise and trend using the **INLA** package (method=\"dlm)\n\nNOTE: This is an experimental function and the \"dlm\" method is used as an example.  Models later in this demo will use the Rt_raw value to forecast concurrently with incidence estimation.   \n\n::: {.cell}\n\n```{.r .cell-code}\nRt_df = Rt_projection(train_data, mean_si = 5.7, std_si = 2, \n                      forecast_horizon = 28, method = \"dlm\")\n```\n:::\n\n\n**Rt Estimates**  \nChecking *Rt_projection()* results  \n\n::: {.cell}\n\n```{.r .cell-code}\nRt_df[1:10,] #check values\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|date       | value|signal |location |location_name |day       |trn_tst | Region| SAEPOVRTALL_PT| age_pop|   Rt_raw|       Rt|\n|:----------|-----:|:------|:--------|:-------------|:---------|:-------|------:|--------------:|-------:|--------:|--------:|\n|2021-06-28 |     2|hosp   |02       |Alaska        |Monday    |train   |     38|            9.6|  184927|       NA|       NA|\n|2021-06-29 |     5|hosp   |02       |Alaska        |Tuesday   |train   |     38|            9.6|  184927|       NA|       NA|\n|2021-06-30 |     2|hosp   |02       |Alaska        |Wednesday |train   |     38|            9.6|  184927|       NA|       NA|\n|2021-07-01 |     6|hosp   |02       |Alaska        |Thursday  |train   |     38|            9.6|  184927|       NA|       NA|\n|2021-07-02 |     3|hosp   |02       |Alaska        |Friday    |train   |     38|            9.6|  184927|       NA|       NA|\n|2021-07-03 |     7|hosp   |02       |Alaska        |Saturday  |train   |     38|            9.6|  184927|       NA|       NA|\n|2021-07-04 |     3|hosp   |02       |Alaska        |Sunday    |train   |     38|            9.6|  184927|       NA|       NA|\n|2021-07-05 |     2|hosp   |02       |Alaska        |Monday    |train   |     38|            9.6|  184927| 3.295300| 3.272205|\n|2021-07-06 |     5|hosp   |02       |Alaska        |Tuesday   |train   |     38|            9.6|  184927| 2.304267| 2.334882|\n|2021-07-07 |     4|hosp   |02       |Alaska        |Wednesday |train   |     38|            9.6|  184927| 1.858476| 1.848652|\n\n</div>\n:::\n\n```{.r .cell-code}\nRt_df %>% \n  filter(trn_tst == \"test\") %>% \n  slice(1:10) #check values (forecast period)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|date       | value|signal |location |location_name |day       |trn_tst | Region| SAEPOVRTALL_PT| age_pop| Rt_raw|       Rt|\n|:----------|-----:|:------|:--------|:-------------|:---------|:-------|------:|--------------:|-------:|------:|--------:|\n|2021-08-24 |    15|hosp   |02       |Alaska        |Tuesday   |test    |     38|            9.6|  184927|     NA| 1.018219|\n|2021-08-25 |    33|hosp   |02       |Alaska        |Wednesday |test    |     38|            9.6|  184927|     NA| 1.051613|\n|2021-08-26 |    18|hosp   |02       |Alaska        |Thursday  |test    |     38|            9.6|  184927|     NA| 1.085007|\n|2021-08-27 |    21|hosp   |02       |Alaska        |Friday    |test    |     38|            9.6|  184927|     NA| 1.118401|\n|2021-08-28 |    14|hosp   |02       |Alaska        |Saturday  |test    |     38|            9.6|  184927|     NA| 1.151794|\n|2021-08-29 |    19|hosp   |02       |Alaska        |Sunday    |test    |     38|            9.6|  184927|     NA| 1.185188|\n|2021-08-30 |    32|hosp   |02       |Alaska        |Monday    |test    |     38|            9.6|  184927|     NA| 1.218582|\n|2021-08-31 |    22|hosp   |02       |Alaska        |Tuesday   |test    |     38|            9.6|  184927|     NA| 1.251977|\n|2021-09-01 |    22|hosp   |02       |Alaska        |Wednesday |test    |     38|            9.6|  184927|     NA| 1.285371|\n|2021-09-02 |    23|hosp   |02       |Alaska        |Thursday  |test    |     38|            9.6|  184927|     NA| 1.318765|\n\n</div>\n:::\n:::\n\n\n\n# Organize Data  \nModel parameters, inputs, and covariates will vary from model-to-model and user-to-user but ultimately all need to be combined in a single object that can be ingested by the the inference software, INLA in this case.   The code below modifies the train_data dataframe to perform any desired scaling and to add several spatial and temporal indices.  \n  \nOrdered integers are used as indices to define timesteps (days, weeks, etc), locations ('Region'), and space*time combinations (e.g., 'ID.Region.Wk' in the next chunk).  The modeling approach is hierarchical, so some indices may be used in multiple levels.  But, each index name must be unique therefore some indices are copied and given slighly different names.  \n\nOnce data is organized, it is reformatted as a list object called a 'datastack' that is passed to the inference software.  Although a daraframe might be more intuitive, a list object is used so that model inputs can be of different lengths.\n   \n\n## Clean Dataframe \nThe *time_index()* function is used to recode a date vector to the desired timestep duration (2-day steps, 1 week steps, etc).  \n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data <- as.data.frame(Rt_df) %>%\n  mutate(\n    s_pop = log(age_pop), #log scale\n    s_pov = as.numeric(scale(SAEPOVRTALL_PT)), #some NAs present.  \n    doy = as.integer(as.factor(date)),\n    doy.1 = doy,\n    Region.Wk = paste0(\"ID\", Region, \"W\", doy), #unique Region*doy combinations ('space-time interaction')\n    ID.Region.Wk = as.integer(as.factor(Region.Wk)), #convert factor levels to integer\n    week = week(date),\n    int_week.1 = as.integer(as.factor(week)),\n    int_week.2 = int_week.1,\n    int_week.3 = int_week.1,\n    threeday_indx = time_index(date, seq(min(date), max(date), by = \"3 days\")),\n    threeday_indx.1 = as.integer(as.factor(threeday_indx)),\n    fourday_indx = time_index(date, seq(min(date), max(date), by = \"4 days\")),\n    fourday_indx.1 = as.integer(as.factor(fourday_indx)),\n    fiveday_indx = time_index(date, seq(min(date), max(date), by = \"5 days\")),\n    fiveday_indx.1 = as.integer(as.factor(fiveday_indx)),\n    eightday_indx = time_index(date, seq(min(date), max(date), by = \"8 days\")),\n    eightday_indx.1 = as.integer(as.factor(eightday_indx)),\n    biweek_indx = time_index(date, seq(min(date), max(date), by = \"14 days\")),\n    biweek_indx.1 = as.integer(as.factor(biweek_indx)),\n    Region.1 = Region, Region.2 = Region, Region.3 = Region, \n                Region.4 = Region, Region.5 = Region\n  ) %>%\n  select(c(-biweek_indx, threeday_indx, fourday_indx, fiveday_indx, eightday_indx))\n\nhead(train_data)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|date       | value|signal |location |location_name |day       |trn_tst | Region| SAEPOVRTALL_PT| age_pop| Rt_raw| Rt|    s_pop|      s_pov| doy| doy.1|Region.Wk | ID.Region.Wk| week| int_week.1| int_week.2| int_week.3|threeday_indx | threeday_indx.1|fourday_indx | fourday_indx.1|fiveday_indx | fiveday_indx.1|eightday_indx | eightday_indx.1| biweek_indx.1| Region.1| Region.2| Region.3| Region.4| Region.5|\n|:----------|-----:|:------|:--------|:-------------|:---------|:-------|------:|--------------:|-------:|------:|--:|--------:|----------:|---:|-----:|:---------|------------:|----:|----------:|----------:|----------:|:-------------|---------------:|:------------|--------------:|:------------|--------------:|:-------------|---------------:|-------------:|--------:|--------:|--------:|--------:|--------:|\n|2021-06-28 |     2|hosp   |02       |Alaska        |Monday    |train   |     38|            9.6|  184927|     NA| NA| 12.12772| -0.8064822|   1|     1|ID38W1    |         2466|   26|          1|          1|          1|2021-06-28    |               1|2021-06-28   |              1|2021-06-28   |              1|2021-06-28    |               1|             1|       38|       38|       38|       38|       38|\n|2021-06-29 |     5|hosp   |02       |Alaska        |Tuesday   |train   |     38|            9.6|  184927|     NA| NA| 12.12772| -0.8064822|   2|     2|ID38W2    |         2477|   26|          1|          1|          1|2021-06-28    |               1|2021-06-28   |              1|2021-06-28   |              1|2021-06-28    |               1|             1|       38|       38|       38|       38|       38|\n|2021-06-30 |     2|hosp   |02       |Alaska        |Wednesday |train   |     38|            9.6|  184927|     NA| NA| 12.12772| -0.8064822|   3|     3|ID38W3    |         2488|   26|          1|          1|          1|2021-07-01    |               2|2021-06-28   |              1|2021-06-28   |              1|2021-06-28    |               1|             1|       38|       38|       38|       38|       38|\n|2021-07-01 |     6|hosp   |02       |Alaska        |Thursday  |train   |     38|            9.6|  184927|     NA| NA| 12.12772| -0.8064822|   4|     4|ID38W4    |         2499|   26|          1|          1|          1|2021-07-01    |               2|2021-07-02   |              2|2021-07-03   |              2|2021-06-28    |               1|             1|       38|       38|       38|       38|       38|\n|2021-07-02 |     3|hosp   |02       |Alaska        |Friday    |train   |     38|            9.6|  184927|     NA| NA| 12.12772| -0.8064822|   5|     5|ID38W5    |         2510|   27|          2|          2|          2|2021-07-01    |               2|2021-07-02   |              2|2021-07-03   |              2|2021-06-28    |               1|             1|       38|       38|       38|       38|       38|\n|2021-07-03 |     7|hosp   |02       |Alaska        |Saturday  |train   |     38|            9.6|  184927|     NA| NA| 12.12772| -0.8064822|   6|     6|ID38W6    |         2521|   27|          2|          2|          2|2021-07-04    |               3|2021-07-02   |              2|2021-07-03   |              2|2021-07-06    |               2|             1|       38|       38|       38|       38|       38|\n\n</div>\n:::\n:::\n\n\n## Response Variable  \nThe response variable may differ between models.  In this case, copying hospital incidence (counts) to a new column, standardizing the distribution, and ensuring that observations for the forecast horizon are coded as NA.  Retaining the scaling object and rewriting as function *obs_scale()* to transform model outputs back to the observation scale later.  \n  \nAgain, response variables are specific to individual model setup so could be scaled differently or not at all to be fit with a different likelihood (Poisson, NegBinomial, etc).  Keeping it simple here.       \n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_data$resp = ifelse(train_data$trn_tst == \"train\", train_data$value, NA) #Set obs value to NA for forecasts periods\n\nresp_scale_obj = scale(train_data$resp, scale=T, center=T) #scaled object\nobs_scale = function(r)r*attr(resp_scale_obj,'scaled:scale') + attr(resp_scale_obj, 'scaled:center') #transform back to observation scale\n\ntrain_data$nrm_resp = as.numeric(resp_scale_obj)\n```\n:::\n\n\n## Format as a Datastack  \nIn this example, data could remain as a dataframe and passed to INLA directly, but as a matter of practice, it is better to format as a list object (datastack).  \n\n::: {.cell}\n\n```{.r .cell-code}\nnrm.lst = list(list(intercept1 = rep(1, dim(train_data)[1])), #custom intercept\n          list(pov_pct = train_data[,\"s_pov\"],                #desired covariates and indices below\n               pop = train_data[,\"s_pop\"],                    #formatting as nrm.lst = list()\n               Rt_raw = train_data[,\"Rt_raw\"],\n               Rt_raw.1 = train_data[,\"Rt_raw\"],\n               Rt = train_data[,\"Rt\"],\n               Rt.1 = train_data[,\"Rt\"],\n               doy = train_data[,\"doy\"],\n               doy.1 = train_data[,\"doy.1\"],\n               doy.2 = train_data[,\"doy.1\"],\n               int_week.1 = train_data[,\"int_week.1\"],\n               int_week.2 = train_data[,\"int_week.2\"],\n               int_week.3 = train_data[,\"int_week.3\"],\n               threeday_indx.1 = train_data[,\"threeday_indx.1\"],\n               fourday_indx.1 = train_data[,\"fourday_indx.1\"],\n               fiveday_indx.1 = train_data[,\"fiveday_indx.1\"],\n               eightday_indx.1 = train_data[,\"eightday_indx.1\"],\n               biwek_indx.1 = train_data[,\"biweek_indx.1\"],\n               Region.1 = train_data[,\"Region.1\"],\n               Region.2 = train_data[,\"Region.2\"],\n               Region.3 = train_data[,\"Region.3\"],\n               Region.4 = train_data[,\"Region.4\"],\n               Region.5 = train_data[,\"Region.5\"],\n               Region_Wk = train_data[,\"ID.Region.Wk\"],\n               dow = train_data[,\"day\"]))\n\nnrm.stk = inla.stack(data = list(Y = train_data$nrm_resp), #Y is response variable\n                                      A = list(1,1),       #option to include matrices, not used in this case\n                                effects = nrm.lst,         #list object from above\n                                    tag = \"nrm\")           #arbitrary name to index searches later \n                                                           #(multiple datastack used in complex models)\n```\n:::\n\n\n\n# Model Priors and Formulae  \nSpecifying all priors and formulas for desired models using [**R-INLA**](https://www.r-inla.org/) syntax.  A deep-dive would be needed to describe in detail, which would be too time consuming for this workflow focused demonstration.  \n  \n### A few notes:\n+ Priors\n  - **pc** refers to [\"Penalizing Complexity\"](https://doi.org/10.1214/16-STS576) \n  - **prec** is \"precision\"  \n  - **cor** is \"correlation\"   \n  - non-PC priors are coded using the distribution name (e.g., norm = \"normal\")  \n+ Formulas \n  - **Y** is the response variable in the datastack\n  - *f()* designates a function, level, or submodel in the hierarchy   \n  - **hyper=** refers to the prior for that *f()* \n\n## Set Priors  \n\n::: {.cell}\n\n```{.r .cell-code}\n#bym prior\nbym_hyper <- list(phi = list(prior = \"pc\", \n                      param = c(0.5, 2/3), \n                      initial = 3), \n               prec = list(prior = \"pc.prec\", \n                       param = c(1, 0.01), \n                       initial = 1.5))  \n#Normal prior\nnorm.prior <- list(theta=list(prior = \"normal\", \n                              param=c(0, 1)))\n\n\n#iid prior\npc_prec_iid <- list(theta = list(prior=\"pc.prec\", \n                                 param=c(0.5, 0.01)))\n\n#ar1 prior\npc_cor_ar1 <- list(theta = list(prior = 'pccor1', \n                                param = c(0.5, 0.9)))\n\n#rw2 prior\npc_rw2 <- list(prec=list(prior=\"pc.prec\", \n                         param=c(0.5,0.01)))\n\n#bundle priors to archive run\npriors.list <- list()\npriors.list[[\"bym_hyper\"]] <- bym_hyper\npriors.list[[\"norm.prior\"]] <- norm.prior\npriors.list[[\"pc_prec_iid\"]] <- pc_prec_iid\npriors.list[[\"pc_cor_ar1\"]] <- pc_cor_ar1\npriors.list[[\"pc_rw2\"]] <- pc_rw2\n```\n:::\n\n\n## Specify Formulas\n**Formula 1:** Random Walk plus noise for each location (i.e., state)  \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.1 = Y ~ -1 +     #remove default intercept\n  intercept1 +       #custom intercept\n  f(doy.1,           #order by time index (daily)\n    constr=TRUE,     #enforced zero mean\n    model=\"rw1\",     #order-1 random walk with noise\n    scale.model = TRUE, #additional internal scaling\n    group = Region.1, #run rw1 model for groups based on location \n    control.group=list(model=\"iid\"), #groups are treated independently\n    hyper=pc_rw2)  #prior for rw2\n```\n:::\n\n\n**Formula 2:** Random Walk plus noise and trend for each location \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.2 = Y ~ -1 +     \n  intercept1 +       \n  f(doy.1,           \n    constr=TRUE,     \n    model=\"rw1\",    \n    scale.model = TRUE, \n    group = Region.1, \n    control.group=list(model=\"iid\"), \n    hyper=pc_rw2) + \n  f(doy.2, model=\"linear\", mean.linear = 0, prec.linear = 0.001) #add linear trend to rw1\n```\n:::\n\n\n**Formula 3:** Common spatial effect for timesteps but each location has separate autoregression \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.3 = Y ~ -1 +    \n  intercept1 +       \n  f(Region.1,        #location index\n    model=\"bym2\",    #spatial effect, Besag-York-Mollie model (the 2 indicates scaling) \n    graph=J,         #Adjacency graph to identify neighbors\n    constr=TRUE,     #enforced zero mean\n    hyper=bym_hyper) + #BYM prior\n  f(doy.1,             #order by time index (daily)\n    model=\"ar1\",       #apply order-1 autoregressive\n    constr=TRUE,\n    group = Region.1,  #run ar1 model for groups based on location\n    control.group=list(model=\"iid\"), #groups are treated independently\n    hyper=pc_cor_ar1) \n```\n:::\n\n\n**Formula 4:** Separate spatial effect for each timestep (related by ar1) and each location has its own autoregressive term. \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.4 = Y ~ -1 +     \n  intercept1 +       \n  f(Region.1,        \n    model=\"bym2\",   \n    graph=J,         \n    constr=TRUE,     \n    group = doy,     #time index, daily (create separate realizations of spatial covariate for each day)\n    control.group=list(model=\"ar1\"), #groups are related via an order-1 autoregressive\n    hyper=bym_hyper) + #prior for BYM\n  f(doy.1,             \n    model=\"ar1\",       \n    constr=TRUE,\n    group = Region.1,  \n    control.group=list(model=\"iid\"), \n    hyper=pc_cor_ar1) \n```\n:::\n\n\n**Formula 5:** As Formula 4 but with space-time interaction to capture location and time specific variation outside of modeled trends.  \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.5 = Y ~ -1 +    \n  intercept1 +       \n  f(Region.1,        \n    model=\"bym2\",    \n    graph=J,         \n    constr=TRUE,    \n    group = doy,     \n    control.group=list(model=\"ar1\"),\n    hyper=bym_hyper) +\n  f(doy.1,             \n    model=\"ar1\",       \n    constr=TRUE,\n    group = Region.1,  \n    control.group=list(model=\"iid\"), \n    hyper=pc_cor_ar1) +\n  f(Region_Wk,   #Index for all location*time combinations (space-time interaction)\n    model=\"iid\", #each location and time combination considered independently\n    constr=TRUE,\n    hyper=pc_prec_iid) \n```\n:::\n\n\n**Formula 6:** As Formula 5 but adding covariate for variation due to day of week (e.g. Monday, Tuesday,...Sunday).  \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.6 = Y ~ -1 +    \n  intercept1 +       \n  f(Region.1,        \n    model=\"bym2\",    \n    graph=J,         \n    constr=TRUE,     \n    group = doy,     \n    hyper=bym_hyper, \n    control.group=list(model=\"ar1\")) +\n  f(doy.1,             \n    model=\"ar1\",       \n    constr=TRUE,\n    group = Region.1,  \n    control.group=list(model=\"iid\"), \n    hyper=pc_cor_ar1) +\n  f(dow,           #discrete variable indicating day of week, e.g. Monday, Tuesday,...Sunday\n    constr=TRUE,\n    model=\"iid\",   #days of week may vary independently\n    group = Region.2, #variation attributed to days of week may differ by location\n    control.group=list(model=\"iid\"), \n    hyper=pc_prec_iid) +\n  f(Region_Wk,   \n    model=\"iid\", \n    constr=TRUE,\n    hyper=pc_prec_iid) \n```\n:::\n\n\n**Formula 7:** Including Rt estimates as an experimental covariate.  Forecast Rt trend estimated from the observation period (training period) to the future (28 days) using an autoregressive model.\n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.7 = Y ~ -1 +     \n  intercept1 +       \n  pov_pct + pop +    \n  f(Region.1,        \n    model=\"bym2\",    \n    graph=J,        \n    constr=TRUE,     \n    group = doy,     \n    hyper=bym_hyper, \n    control.group=list(model=\"ar1\")) + \n  f(doy.1, Rt_raw,  #order by time index (daily) but weight each timestep by corresponding Rt_raw estimate\n    model=\"ar1\",    #apply order-1 autoregressive to Rt weighted time index above\n    constr=TRUE,\n    group = Region.2, \n    control.group=list(model=\"iid\"),\n    hyper=pc_cor_ar1) +\n  f(dow,           \n    constr=TRUE,\n    model=\"iid\",\n    group = Region.3,\n    control.group=list(model=\"iid\"),\n    hyper=pc_prec_iid) +\n  f(Region_Wk,   \n    model=\"iid\", \n    constr=TRUE,\n    hyper=pc_prec_iid) \n```\n:::\n\n\n**Formula 8:** As with Formula 8 but adding a random walk at a more coarse time scale (3 day steps) to reduce forecast decay.   \n\n::: {.cell}\n\n```{.r .cell-code}\nFrm.8 = Y ~ -1 +     \n  intercept1 +       \n  pov_pct + pop +    #linear covariates for poverty and population over 55yrs\n  f(Region.1,        \n    model=\"bym2\",    \n    graph=J,        \n    constr=TRUE,     \n    group = doy,    \n    hyper=bym_hyper, \n    control.group=list(model=\"ar1\")) + \n  f(threeday_indx.1, #time index, 3days\n    constr=TRUE,\n    model=\"rw2\",     #order-2 random walk with noise\n    scale.model = TRUE,\n    group = Region.2,\n    control.group=list(model=\"iid\"), \n    hyper=pc_rw2) + \n  f(doy.1, Rt_raw,  \n    model=\"ar1\",    \n    constr=TRUE,\n    group = Region.3, \n    control.group=list(model=\"iid\"),\n    hyper=pc_cor_ar1) +\n  f(dow,           \n    constr=TRUE,\n    model=\"iid\",\n    group = Region.4,\n    control.group=list(model=\"iid\"),\n    hyper=pc_prec_iid) +\n  f(Region_Wk,   \n    model=\"iid\", \n    constr=TRUE,\n    hyper=pc_prec_iid) \n```\n:::\n\n\n**Organize Formulas**\n\n::: {.cell}\n\n```{.r .cell-code}\nformulas.list <- list()\nformulas.list[[\"base_rw1\"]] <- Frm.1\nformulas.list[[\"rw1_trend\"]] <- Frm.2\nformulas.list[[\"base_car\"]] <- Frm.3\nformulas.list[[\"car_time\"]] <- Frm.4\nformulas.list[[\"car_sti\"]] <- Frm.5\nformulas.list[[\"car_wdays\"]] <- Frm.6\nformulas.list[[\"car_rt\"]] <- Frm.7\nformulas.list[[\"car_full\"]] <- Frm.8\n```\n:::\n\n\n# Run Models\nThe *run_model_list()* function runs a series of models as specified in the **formulas.list** using the input data organized as a datastack (nrm.srk).  The function runs each model sequentially and writes the executed models (models_out), formulas (formulas.list), priors (prior.list), datastack, and original dataframe (train_data) to an **.RData** in the analysis directory.  The **models_out** object will also be available in the environment for further processing.  \n  \nThere are many customization options for inference but have opted to keep *run_model_list()* fairly simple for ease of use and maximum efficiency.  \n\n#### Addional *run_model_list()* options:\n+ **likelihood**  \n  - If one likelihood is provided it will be applied to all models  \n  - A vector of likelihoods can be provided with order based on **formulas.list**  \n  - e.g., myFamilies <- c(\"gaussian\", \"binomial\", \"zeroinflatednbinomial\", ...) \n+ **config** \n  - indicates if latencies (GMRF) should be retained for sampling  \n  - **config=TRUE** can be time intensive and dramatically slow model runs\n  - CovidCAR has a *post_sampling()* function to facilitate sampling \n+ **verbose** prints INLA algorithm process to screen during model runs   \n+ **archive** indicates to save model inputs and results to the analysis directory \n  - model outputs will be written to a *run_archive* subdirectory\n  \n## Run All Models   \n\n::: {.cell}\n\n```{.r .cell-code}\nformulas.list = formulas.list[c(1:4)] #short list for demo, fast run models\n\nmodels_out = run_model_list(formulas.list=formulas.list,\n                            dataStack=nrm.stk,\n                            likelihood = \"gaussian\",\n                            config=FALSE, verbose = FALSE, archive=TRUE)\n```\n:::\n\n\n# Extract and Format Forecasts\nThe *extract_forecasts()* function pulls forecasts from models and saves them to a *forecasts* folder in analysis directory.  The function returns a *forecast_paths* list object to the environment with file path names. \n  \nForecasts are formatted to the specifications required for submission to the [covid19-forecast-hub](https://github.com/reichlab/covid19-forecast-hub).  \n\n::: {.cell}\n\n```{.r .cell-code}\n#models_out[[\"full_mod\"]] <- full_model\nextract_forecasts(mod_out=models_out,\n                  dataStack=nrm.stk, train_data=train_data,\n                  team = \"CFA\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ Writing model forecasts to analysis directory: \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ base_rw1 [871ms]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ Writing model forecasts to analysis directory: \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ rw1_trend [964ms]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ Writing model forecasts to analysis directory: \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ base_car [900ms]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nℹ Writing model forecasts to analysis directory: \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ car_time [855ms]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\n```\n:::\n\n```{.r .cell-code}\n#check returned object\nnames(forecast_paths)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"base_rw1\"  \"rw1_trend\" \"base_car\"  \"car_time\" \n```\n:::\n\n```{.r .cell-code}\nhead(read.csv(forecast_paths[[\"rw1_trend\"]])) #formatted for submission\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|forecast_date |location |target               |target_end_date |type     | quantile|    value|\n|:-------------|:--------|:--------------------|:---------------|:--------|--------:|--------:|\n|2021-08-23    |02       |0 day ahead inc hosp |2021-08-23      |quantile |     0.01| 18.04364|\n|2021-08-23    |02       |1 day ahead inc hosp |2021-08-24      |quantile |     0.01|  0.00000|\n|2021-08-23    |02       |2 day ahead inc hosp |2021-08-25      |quantile |     0.01|  0.00000|\n|2021-08-23    |02       |3 day ahead inc hosp |2021-08-26      |quantile |     0.01| 15.77363|\n|2021-08-23    |02       |4 day ahead inc hosp |2021-08-27      |quantile |     0.01| 48.06863|\n|2021-08-23    |02       |5 day ahead inc hosp |2021-08-28      |quantile |     0.01| 83.54071|\n\n</div>\n:::\n:::\n\n\n\n**View forecasts**\n*extract_forecasts()* also returns a list ('plot_paths') of paths to plotting data from the extraction process.  This data can be accessed from the *plot_location()* function, which provides a quick diagnostic plot of forecast for a specific location.  \n   \nNote of Caution: If the 'loc=' option is left as NULL, all locations will be plotted to PDF file and saved in the 'Reports' folder of the analysis directory.  This may be time consuming!   \n\n::: {.cell}\n\n```{.r .cell-code}\nOK_plot = plot_location(plot_path = plot_paths, model = \"base_car\", loc = \"Oklahoma\")\nOK_plot\n```\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n\n```{.r .cell-code}\nAR_plot = plot_location(plot_path = plot_paths, model = \"base_car\", loc = \"Arkansas\")\nAR_plot\n```\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-32-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#plot_location(plot_path = plot_paths, model = \"full_mod\") #plots and saves all locations to a pdf file\n```\n:::\n\n\n# Model Scoring\n\n## WIS Scores  \nThe *score_WIS()* function calculates the WIS score for forecasts by model.  Optional arguments can be included to indicate if files should be read from a directory (ingest = \"path\"), a dataframe in the environment (ingest = \"dataframe\"),or from a list object with individual file paths (ingest = \"list\") as returned by *extract_forecasts()*.\n  \nThe 'missing' option can be used to specify how missing observation data should be handled; 'remove' from data or fill with 'zero'.    \n\n::: {.cell}\n\n```{.r .cell-code}\nmy_truth <- train_data %>% #Caution: my_truth may be different than your truth :)\n  select(date, location, value)\n\nmy_scores <- score_WIS(forecast_data = forecast_paths, truth=my_truth, \n                       ingest = \"list\", missing = \"remove\") \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ A total of 2668 predictions weren't evalauted due lack of truth data\n```\n:::\n\n```{.r .cell-code}\nhead(my_scores)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model    |date       |location_name |forecast_date |       WIS|\n|:--------|:----------|:-------------|:-------------|---------:|\n|base_car |2021-08-23 |01            |2021-08-23    | 0.5471048|\n|base_car |2021-08-23 |02            |2021-08-23    | 0.5186350|\n|base_car |2021-08-23 |04            |2021-08-23    | 0.5279331|\n|base_car |2021-08-23 |05            |2021-08-23    | 0.5578004|\n|base_car |2021-08-23 |06            |2021-08-23    | 0.5507474|\n|base_car |2021-08-23 |08            |2021-08-23    | 0.5235968|\n\n</div>\n:::\n\n```{.r .cell-code}\n#overall\nwis_rank <- my_scores %>%\n  group_by(model) %>%\n  summarise(mean_wis = mean(WIS)) %>%\n  arrange(mean_wis) %>%\n  mutate(wisRank = row_number())\n\nwis_rank #mean absolute values\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model     |  mean_wis| wisRank|\n|:---------|---------:|-------:|\n|base_car  |  34.41192|       1|\n|car_time  |  34.46840|       2|\n|base_rw1  | 280.88099|       3|\n|rw1_trend | 307.12383|       4|\n\n</div>\n:::\n:::\n\n\n**Diagnostic score plots**  \nThe *plot_WIS_lines()* function has options to make quick plots of WIS scores returned by *score_WIS()*.   \n\n::: {.cell}\n\n```{.r .cell-code}\nunique(my_scores$model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"base_car\"  \"base_rw1\"  \"car_time\"  \"rw1_trend\"\n```\n:::\n\n```{.r .cell-code}\n#lines showing absolute WIS\nplot_WIS_lines(my_scores, by = \"date\", range = \"abs\")\n```\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#lines showing scaled WIS\nplot_WIS_lines(my_scores, by = \"date\", range = \"scaled\", \n               scale_model = \"base_rw1\")\n```\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-34-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#optional 'limit' that recodes: (WIS >= limit) -> limit\nplot_WIS_lines(my_scores, by = \"date\", range = \"scaled\", \n               scale_model = \"base_rw1\", limit = 2)\n```\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-34-3.png){width=672}\n:::\n\n```{.r .cell-code}\n#tile option\nplot_WIS_lines(my_scores, by = \"tile\", range = \"scaled\", \n               scale_model = \"base_rw1\", limit = 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Removed 432 rows containing missing values (`geom_tile()`).\n```\n:::\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-34-4.png){width=672}\n:::\n:::\n\n\n## Mean Absolute Error (MAE)  \nThe *score_MAE()* function works comparably to *score_WIS()* but is a simpler measure of model performance as it is based on only the point estimates from forecasts.  \n\n::: {.cell}\n\n```{.r .cell-code}\nmy_mae <- score_MAE(forecast_data = forecast_paths, truth=my_truth, ingest = \"list\", missing = \"remove\") \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ A total of 116 forecasts weren't evaluatd due lack of truth data\n```\n:::\n\n```{.r .cell-code}\nmy_mae\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model     |   MAE|    MAPE| maeRank|\n|:---------|-----:|-------:|-------:|\n|base_car  |  41.2| 0.01243|       1|\n|car_time  |  42.0| 0.01266|       2|\n|base_rw1  | 325.6| 0.09818|       3|\n|rw1_trend | 353.3| 0.10652|       4|\n\n</div>\n:::\n:::\n\n\n# Ensemble\nThe *propose_weights()* function assists with ensemble building by weighting models using a given performance metric.  The function scales the raw model comparison metric and then builds the ensemble by multiplying each forecasts by its model-specific weight and summing across all included models.  The resulting ensemble forecast is then standardized for Covid19-hub submission and written to the analysis directory (./forecasts).  The function returns the estimated weights to the environment.    \n   \nFor example, the WIS and MAE scores could be used to weight individual models in an ensemble.  \n  \nFirst, compare WIS and MAE scores:  \n\n::: {.cell}\n\n```{.r .cell-code}\nmod_rank <- left_join(my_mae, wis_rank, by=\"model\") #combine with overall WIS\n\nmod_rank #note the scores rank models differently  \n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model     |   MAE|    MAPE| maeRank|  mean_wis| wisRank|\n|:---------|-----:|-------:|-------:|---------:|-------:|\n|base_car  |  41.2| 0.01243|       1|  34.41192|       1|\n|car_time  |  42.0| 0.01266|       2|  34.46840|       2|\n|base_rw1  | 325.6| 0.09818|       3| 280.88099|       3|\n|rw1_trend | 353.3| 0.10652|       4| 307.12383|       4|\n\n</div>\n:::\n:::\n\n\nThe *propose_weights()* function can the be applied to generate weights and write the resulting ensemble.  \n\n::: {.cell}\n\n```{.r .cell-code}\nmy_wis_weights <- propose_weights(forecast_data = forecast_paths, #standardized model forecasts\n                             ingest = \"list\",                     #read model locations as list\n                             rank_df = mod_rank,                  #use the data from WIS and MAE scoring         \n                             rankCol = \"mean_wis\",                #weight models based on this column\n                             team = \"CFA\",                        #team name (need be in file name per Covid19hub)\n                             mod_name = \"wis_ensemble\")           #label for the new ensemble forecast\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Writing ensemble 'wis_ensemble' to analysis directory\n```\n:::\n\n```{.r .cell-code}\nmy_wis_weights #The weights column reports the actual weights calculated for each model\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model     |   MAE|    MAPE| maeRank|  mean_wis| wisRank| mean_wis_weights|\n|:---------|-----:|-------:|-------:|---------:|-------:|----------------:|\n|base_car  |  41.2| 0.01243|       1|  34.41192|       1|        0.3158712|\n|car_time  |  42.0| 0.01266|       2|  34.46840|       2|        0.3158425|\n|base_rw1  | 325.6| 0.09818|       3| 280.88099|       3|        0.1908016|\n|rw1_trend | 353.3| 0.10652|       4| 307.12383|       4|        0.1774848|\n\n</div>\n:::\n\n```{.r .cell-code}\n#another example,this time using MAE and including a 'drop' option\nmy_mae_weights <- propose_weights(forecast_data = forecast_paths, \n                             ingest = \"list\",\n                             rank_df = mod_rank, \n                             rankCol = \"MAE\",\n                             drop = 1,  #number of lowest ranked models to drop/exclude from ensemble\n                             team = \"CFA\",\n                             mod_name = \"mae_ensemble\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Dropped models: rw1_trend\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Writing ensemble 'mae_ensemble' to analysis directory\n```\n:::\n\n```{.r .cell-code}\nmy_mae_weights\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model    |   MAE|    MAPE| maeRank|  mean_wis| wisRank| MAE_weights|\n|:--------|-----:|-------:|-------:|---------:|-------:|-----------:|\n|base_car |  41.2| 0.01243|       1|  34.41192|       1|   0.4496086|\n|car_time |  42.0| 0.01266|       2|  34.46840|       2|   0.4486301|\n|base_rw1 | 325.6| 0.09818|       3| 280.88099|       3|   0.1017613|\n\n</div>\n:::\n\n```{.r .cell-code}\n#yet another example, not providing a rankCol -> function assumes equal weighting \nequal_mae_weights <- propose_weights(forecast_data = forecast_paths, \n                             ingest = \"list\",\n                             rank_df = mod_rank, \n                             #rankCol = NULL,\n                             drop = 1,  #issues warning, dropping models without a ranking criteria\n                             team = \"CFA\",\n                             mod_name = \"equal_mae_ensemble\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n✖ No rankCol but dropping models? Models will be dropped from end of list!\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n! No rankCol provided, ensemble assumes equal weighting\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Dropped models: rw1_trend\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Writing ensemble 'equal_mae_ensemble' to analysis directory\n```\n:::\n\n```{.r .cell-code}\nequal_mae_weights\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model    |   MAE|    MAPE| maeRank|  mean_wis| wisRank| rankCol| rankCol_weights|\n|:--------|-----:|-------:|-------:|---------:|-------:|-------:|---------------:|\n|base_car |  41.2| 0.01243|       1|  34.41192|       1|       1|       0.3333333|\n|car_time |  42.0| 0.01266|       2|  34.46840|       2|       1|       0.3333333|\n|base_rw1 | 325.6| 0.09818|       3| 280.88099|       3|       1|       0.3333333|\n\n</div>\n:::\n:::\n\n\n\n## Ensemble Re-scoring  \nNow that new ensembles have been added to the 'forecasts' directory, comparison scores can be recalculated.\n\n::: {.cell}\n\n```{.r .cell-code}\nmyDir <- file.path(su_yaml$out_dir_name, \"forecasts\")\nnew_mae <- score_MAE(forecast_data = myDir, truth=my_truth, ingest = \"path\", missing = \"remove\") \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ A total of 203 forecasts weren't evaluatd due lack of truth data\n```\n:::\n\n```{.r .cell-code}\nnew_mae\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model              |   MAE|    MAPE| maeRank|\n|:------------------|-----:|-------:|-------:|\n|base_car           |  41.2| 0.01243|       1|\n|car_time           |  42.0| 0.01266|       2|\n|mae_ensemble       |  50.8| 0.01532|       3|\n|equal_mae_ensemble | 105.5| 0.03180|       4|\n|wis_ensemble       | 120.6| 0.03638|       5|\n|base_rw1           | 325.6| 0.09818|       6|\n|rw1_trend          | 353.3| 0.10652|       7|\n\n</div>\n:::\n:::\n\n\n\n\n## Historic Forecasts\nThe *get_hub_forecasts()* function retrieves forecasts previously submitted to the [covid19-forecast-hub](https://github.com/reichlab/covid19-forecast-hub).    \n    \nSimilar to *get_covid19_obs()*, there are options to load from a local parquet cache (source=\"cache\") as indexed with the [**Covid19Forecasts** package](https://github.com/cdcent/covid19Forecasts)(private repo) or to load \"test\" data included with the package.  There is also the an option to use the [**covidHubUtils** package](https://github.com/reichlab/covidHubUtils) to download data directly from covid19-forecast-hub.  \n  \nThe queried results can also be filtered to specific models using the 'models=' option.  If not set, the 'model=' options defaults to forecasts from the COVIDhub-trained_ensemble, COVIDhub-ensemble, and COVIDhub-baseline models. \n  \nBy default, *get_hub_forecasts()* returns forecasts for the forecast period specified during initial setup using *setup_analysis()*. \n\n::: {.cell}\n\n```{.r .cell-code}\nhist_forecasts <- get_hub_forecasts(source = \"covidHubUtils\",\n                                    models = c(\"COVIDhub-trained_ensemble\", \"COVIDhub-baseline\", \"COVIDhub-ensemble\"),\n                                    write_copy = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Loading location crosswalk\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 57 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"|\"\nchr (4): STATE, STUSAB, STATE_NAME, STATENS\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n→ Fetching COVID-19 forecasts using covidHubUtils\n\nget_token(): POST: https://zoltardata.com/api-token-auth/\n\nget_resource(): GET: https://zoltardata.com/api/projects/\n\nget_resource(): GET: https://zoltardata.com/api/project/44/models/\n\nget_resource(): GET: https://zoltardata.com/api/project/44/timezeros/\n\n→ Writing forecast data to analysis directory\n```\n:::\n\n```{.r .cell-code}\ndim(hist_forecasts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 103032      7\n```\n:::\n\n```{.r .cell-code}\nhead(hist_forecasts)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model                     |forecast_date |location |target_end_date |type     | quantile| value|\n|:-------------------------|:-------------|:--------|:---------------|:--------|--------:|-----:|\n|COVIDhub-trained_ensemble |2021-08-23    |01       |2021-08-24      |point    |       NA|   495|\n|COVIDhub-trained_ensemble |2021-08-23    |01       |2021-08-24      |quantile |    0.010|   369|\n|COVIDhub-trained_ensemble |2021-08-23    |01       |2021-08-24      |quantile |    0.025|   384|\n|COVIDhub-trained_ensemble |2021-08-23    |01       |2021-08-24      |quantile |    0.050|   395|\n|COVIDhub-trained_ensemble |2021-08-23    |01       |2021-08-24      |quantile |    0.100|   404|\n|COVIDhub-trained_ensemble |2021-08-23    |01       |2021-08-24      |quantile |    0.150|   412|\n\n</div>\n:::\n\n```{.r .cell-code}\n#because data is formatted to same standard, functions can read\nhub_rank <- score_WIS(forecast_data = hist_forecasts, truth=my_truth, \n                      ingest = \"dataframe\", missing = \"remove\")\n\nhub_rank %>%\n  group_by(model) %>%\n  summarise(mean_wis = mean(WIS))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|model                     | mean_wis|\n|:-------------------------|--------:|\n|COVIDhub-baseline         | 45.61759|\n|COVIDhub-ensemble         | 50.61499|\n|COVIDhub-trained_ensemble | 68.17765|\n\n</div>\n:::\n:::\n\n\n\n**Combine with CovidCAR models**  \nThe *plot_forecasts_compare()* function combines *plot_WIS_lines()* and *score_WIS()* to make a model WIS comparison line plot.  The 'hub_forecasts' option facilitates direct use of imported historical forecast data from the Covid19-forecast-hub.    \n\n::: {.cell}\n\n```{.r .cell-code}\nmy_plot <- plot_forecasts_compare(forecast_data = myDir, truth=my_truth, ingest = \"path\",\n                                  hub_forecasts = hist_forecasts,\n                                  scale_model = \"COVIDhub-baseline\",\n                                  limit = 4,\n                                  missing = \"remove\",\n                                  write_copy = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n→ A total of 4669 predictions weren't evalauted due lack of truth data\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n→ Writing comparison scores to analysis directory\n```\n:::\n\n```{.r .cell-code}\nclass(my_plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"gg\"     \"ggplot\"\n```\n:::\n\n```{.r .cell-code}\nmy_plot\n```\n\n::: {.cell-output-display}\n![](ccintro_files/figure-html/unnamed-chunk-40-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "ccintro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}